// Реализуйте функцию checkBrackets, которая должна проверять правильность расположения скобок в строке. (скобки)
/* Создайте функцию, которая принимает строку, состоящую из скобок, и возвращает true, если все скобки закрыты правильно.

Примеры:
 "()"              =>  true
 ")(()))"          =>  false
 "("               =>  false
 "(())((()())())"  =>  true */
// сложное решение
const checkBrackets = (str) => !str.split('').reduce((acc, curr) => (!acc ? curr : '[]{}()'.includes(acc.slice(-1)[0] + curr) ? acc.substring(0, acc.length - 1) : acc + curr), '');

// Start: Решение Александра
const str = ')(()))';

function findPairs(str) {
	// создаем копию с уже замененной подстрокой. то есть у нас есть как оригинальная строка, так и копия, ток она возможно уже будет короче
	let copyStr = str.replace('()', '');

	if (copyStr.length > 0 && copyStr.length === str.length) {
		// если после обрезки у нас длина копии равна длине str, то получается обрезка получилась неудачно, то есть че то в строке есть, но это не пара. значит сразу говорим false
		return false;
	} else if (copyStr.length === 0) {
		// иначе если после обрезки осталась пустая строка, то получается что в ней были пары и мы их вырезали и осталась пустая строка. это хорошо. вернем true
		return true;
	} else {
		// как ток изменилась длина строки copyStr, то меняем строку str, у нее ж тоже получается
		str = copyStr;
		// здесь просто надо уловить, что мы из копии вырезали скобки аж целую пару. длина копии != длине оригинала. значит еще раз ищем пару в копии. до тех пор, пока не дойдем в первый или второй if
		return findPairs(str);
	}
}

console.log(findPairs(str));
// End: Решение Александра

// Ещё решение
let c1 = 0;
let c2 = 0;

for (let i = 0; i < str.length; i++) {
	if (str[i] === '(') c1++;
	else c2++;
}

return c1 === c2;
